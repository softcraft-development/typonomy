import { describe, expect, it } from "vitest"
import * as lib from "../src/arrays"
import type { Explicit } from "../src/nullish"
import { isNumber } from "../src/types"

describe("arrays", () => {
  describe("Explicit<T>", () => {
    it("is assignable to T", () => {
      const explicitType: Explicit<number> = 42
      const generalType: number = explicitType
      expect(generalType).toBe(explicitType)
    })
  })

  describe("append", () => {
    it("should append the value to the array", () => {
      const array = [1, 1, 2, 3]
      const result = lib.append(array, 5)
      expect(result).toEqual([1, 1, 2, 3, 5])
    })

    it("should mutate the original array", () => {
      const array = [1, 1, 2, 3]
      const result = lib.append(array, 7)
      expect(result).toBe(array)
    })
  })

  describe("appendExplicit", () => {
    it("appends a definite value", () => {
      const result = lib.appendExplicit<string>([], "Explicit")
      expect(result).toEqual(["Explicit"])
    })

    it("does not append a null", () => {
      const result = lib.appendExplicit<string>([], null)
      expect(result).toEqual([])
    })

    it("does not append undefined", () => {
      const result = lib.appendExplicit<string>([], undefined)
      expect(result).toEqual([])
    })
  })

  describe("arrayGuard", () => {
    describe("when emptyMatches is true", () => {
      it("returns a type guard that returns true for an empty array", () => {
        expect(lib.arrayGuard(isNumber, true)([])).toBe(true)
      })
    })

    describe("when emptyMatches is false", () => {
      it("returns a type guard that returns false for an empty array", () => {
        expect(lib.arrayGuard(isNumber, false)([])).toBe(false)
      })
    })

    it("returns a type guard that validates against the predicate", () => {
      expect(lib.arrayGuard(isNumber)([1, 2, 3])).toBe(true)
    })
  })

  describe("create", () => {
    it("returns an array of the specified size", () => {
      const result = lib.create(5)
      expect(result.length).toBe(5)
    })

    it("returns an empty array if no size is specified", () => {
      const result = lib.create()
      expect(result.length).toBe(0)
    })
  })

  describe("isArrayOf", () => {
    describe("when the value is an empty array", () => {
      describe("and emptyMatches is true", () => {
        it("returns true", () => {
          expect(lib.isArrayOf([], isNumber, true)).toBe(true)
        })
      })

      describe("and emptyMatches is false", () => {
        it("returns false", () => {
          expect(lib.isArrayOf([], isNumber, false)).toBe(false)
        })
      })
    })

    describe("when the value is an filled array", () => {
      describe("and the array contains only values of that type", () => {
        it("returns true", () => {
          expect(lib.isArrayOf([1, 2, 3], isNumber)).toBe(true)
        })
      })

      describe("and the array contains any values not of that type", () => {
        it("returns false", () => {
          expect(lib.isArrayOf([1, 2, "3"], isNumber)).toBe(false)
        })
      })
    })

    it("returns false if the value is of the array type", () => {
      expect(lib.isArrayOf(1, isNumber)).toBe(false)
    })

    it("returns false for null", () => {
      expect(lib.isArrayOf(null, isNumber)).toBe(false)
    })

    it("returns false for null", () => {
      expect(lib.isArrayOf(undefined, isNumber)).toBe(false)
    })

    it("returns false for a string", () => {
      expect(lib.isArrayOf("test", isNumber)).toBe(false)
    })

    it("returns false for an object", () => {
      expect(lib.isArrayOf({}, isNumber)).toBe(false)
    })
  })

  describe("fill", () => {
    it("should fill the array with values generated by the filler function", () => {
      const filler = (value: number) => value * 2
      const result = lib.fill(4, filler)
      expect(result).toEqual([2, 4, 6, 8])
    })
  })

  describe("isEmptyArray", () => {
    it("returns true for an empty array", () => {
      expect(lib.isEmptyArray([])).toBe(true)
    })

    it("returns false a filled Array", () => {
      expect(lib.isEmptyArray([1, 2])).toBe(false)
    })

    it("returns false for null", () => {
      expect(lib.isEmptyArray(null)).toBe(false)
    })

    it("returns false for undefined", () => {
      expect(lib.isEmptyArray(undefined)).toBe(false)
    })
  })

  describe("wrap", () => {
    describe("when the input is an array", () => {
      it("returns the input array as is", () => {
        const array = [1, 2, 3]
        const result = lib.wrap(array)
        expect(result).toBe(array)
      })
    })

    describe("when the input is a single value", () => {
      it("wrap the value in an array", () => {
        const value = 42
        const result = lib.wrap(value)
        expect(result).toEqual([value])
      })
    })
  })
})
